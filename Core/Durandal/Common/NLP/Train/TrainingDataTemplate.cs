namespace Durandal.Common.NLP.Train
{
    using Durandal.API;
    using Durandal.Common.File;
    using Durandal.Common.Logger;
    using Durandal.Common.Utils;
    using Durandal.Common.MathExt;
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;
    using Durandal.Common.NLP.Language;
    using Durandal.Common.Collections;

    public class TrainingDataTemplate
    {
        private static readonly Regex catalogNameExtractor = new Regex("#catalog=(.+?)#");
        private static readonly Regex groupNameExtractor = new Regex("#(.+?)#");
        private static readonly Regex regexSubExtractRegex = new Regex("\\{\\{(.+?)\\}\\}");

        private const int TYPO_THRESHOLD = 2;
        private const string STATIC_GROUP_NAME = "static";

        private List<TrainingUtterance> allPatterns = new List<TrainingUtterance>();
        private List<TrainingUtterance> allStatics = new List<TrainingUtterance>();
        private List<TrainingUtterance> whitelistRegex = new List<TrainingUtterance>();
        private List<TrainingUtterance> blacklistRegex = new List<TrainingUtterance>();
        private Dictionary<string, string[]> allGroups = new Dictionary<string, string[]>();
        private readonly VirtualPath _originalFileName;
        private readonly ILogger _logger;
        private readonly VirtualPath _catalogDirectory;
        private readonly LanguageCode _locale = LanguageCode.UNDETERMINED;
        private readonly bool _loadCatalogs;
        private string _domain = string.Empty;
        
        /// <summary>
        /// The state object for the parser's state machine
        /// </summary>
        private enum TemplateGroup
        {
            Static,
            Patterns,
            Regex,
            RegexBlacklist,
            Catalog,
            Group
        }

        public TrainingDataTemplate(ILogger logger, LanguageCode locale, bool loadCatalogs = true)
        {
            _logger = logger;
            _locale = locale;
            _catalogDirectory = new VirtualPath(RuntimeDirectoryName.CATALOG_DIR + "/" + locale.ToBcp47Alpha2String());
            _loadCatalogs = loadCatalogs;
            _originalFileName = new VirtualPath("Autogenerated template");
        }

        public TrainingDataTemplate(VirtualPath fileName, IFileSystem fileSystem, LanguageCode locale, ILogger logger, bool loadCatalogs = true, bool warnAboutSparseData = false)
            : this(logger, locale, loadCatalogs)
        {
            Counter<string> intentCounter = new Counter<string>();
            _originalFileName = fileName;
            TemplateGroup currentGroupType = TemplateGroup.Static;
            string currentGroupName = STATIC_GROUP_NAME;
            List<string> itemsInCurrentGroup = new List<string>();
            using (StreamReader reader = new StreamReader(fileSystem.OpenStream(fileName, FileOpenMode.Open, FileAccessMode.Read)))
            {
                while (!reader.EndOfStream)
                {
                    string nextLine = reader.ReadLine();
                    // Skip whitespace and comments
                    if (string.IsNullOrWhiteSpace(nextLine) || nextLine.StartsWith(";"))
                    {
                        continue;
                    }

                    if (nextLine.StartsWith("#") && nextLine.EndsWith("#"))
                    {
                        // Finalize the previous group
                        FinalizeGroup(currentGroupName, currentGroupType, itemsInCurrentGroup, intentCounter);

                        // Switch context to the new group
                        itemsInCurrentGroup.Clear();

                        if (nextLine.ToLowerInvariant().Equals("#patterns#"))
                        {
                            currentGroupType = TemplateGroup.Patterns;
                        }
                        else if (nextLine.ToLowerInvariant().Equals("#static#"))
                        {
                            currentGroupType = TemplateGroup.Static;
                        }
                        else if (nextLine.ToLowerInvariant().Equals("#regex#"))
                        {
                            currentGroupType = TemplateGroup.Regex;
                        }
                        else if (nextLine.ToLowerInvariant().Equals("#regex-blacklist#"))
                        {
                            currentGroupType = TemplateGroup.RegexBlacklist;
                        }
                        else
                        {
                            // Read external catalog files if they were specified
                            string catalogName = StringUtils.RegexRip(catalogNameExtractor, nextLine, 1, logger);
                            if (!string.IsNullOrEmpty(catalogName))
                            {
                                currentGroupType = TemplateGroup.Catalog;
                                currentGroupName = StringUtils.RegexRip(groupNameExtractor, nextLine, 1, logger);
                                if (string.IsNullOrEmpty(currentGroupName))
                                {
                                    throw new FormatException("Badly formatted group tag: " + nextLine);
                                }
                                string[] catalogFiles = catalogName.Split(';');
                                List<string> catalogData = new List<string>();
                                if (_loadCatalogs)
                                {
                                    foreach (string file in catalogFiles)
                                    {
                                        // Navigate to the catalog sub-directory if one is present
                                        string actualFileName = file;
                                        string rootDir = _catalogDirectory.FullName;
                                        int slashIndex = file.IndexOfAny(new char[] { '/', '\\' });
                                        if (slashIndex >= 0)
                                        {
                                            rootDir += "/" + file.Substring(0, slashIndex);
                                            actualFileName = file.Substring(slashIndex + 1);
                                        }
                                        VirtualPath catalogFileName =
                                            new VirtualPath(rootDir + "/" + actualFileName + ".catalog");
                                        if (!fileSystem.Exists(catalogFileName))
                                        {
                                            throw new FormatException("Catalog file " + catalogFileName +
                                                                      " could not be found! (referenced in " +
                                                                      _originalFileName + ")");
                                        }
                                        IReadOnlyCollection<string> lines = fileSystem.ReadLines(catalogFileName);
                                        itemsInCurrentGroup.FastAddRangeReadOnlyCollection(lines);
                                    }
                                }
                                //AddGroup(currentGroupName, catalogData.ToArray());
                            }
                            else
                            {
                                // It's a regular old group
                                currentGroupType = TemplateGroup.Group;
                                currentGroupName = nextLine.Trim('#').ToLowerInvariant();
                                if (currentGroupName.Contains("#"))
                                    throw new FormatException("Badly formatted group tag: " + nextLine);
                            }
                        }

                        // TODO: Not sure what this next block is for; maybe I need to change the condition....
                        if (currentGroupType != TemplateGroup.Catalog)
                        {
                            itemsInCurrentGroup = new List<string>();
                        }
                    }
                    else
                    {
                        // It's a training line. Put it in the holding bucket for processing later
                        itemsInCurrentGroup.Add(nextLine);
                    }
                }

                reader.Dispose();

                // Finalize the last group of the file
                FinalizeGroup(currentGroupName, currentGroupType, itemsInCurrentGroup, intentCounter);
            }

            FinalizeRegexes();

            // If there are domains/intents that have a low count, inform the user (on the assumption that there is a typo)
            if (warnAboutSparseData)
            {
                foreach (KeyValuePair<string, float> intentWithCount in intentCounter)
                {
                    if (intentWithCount.Value <= TYPO_THRESHOLD)
                    {
                        _logger.Log(fileName.Name + " " + locale + ": The intent \"" + intentWithCount.Key + "\" has only " + intentWithCount.Value + " training instance(s); is this intentional?", LogLevel.Wrn);
                    }
                }
            }
            _logger.Log("Loaded " + locale + " templates from " + fileName, LogLevel.Vrb);
        }

        public IEnumerable<TrainingUtterance> Patterns
        {
            get { return allPatterns; }
        }

        public IEnumerable<TrainingUtterance> Statics
        {
            get { return allStatics; }
        }

        public IEnumerable<TrainingUtterance> RegexWhitelist
        {
            get { return whitelistRegex; }
        }

        public IEnumerable<TrainingUtterance> RegexBlacklist
        {
            get { return blacklistRegex; }
        }

        public VirtualPath OriginalFileName
        {
            get { return _originalFileName; }
        }

        /// <summary>
        /// Returns the domain that this template file belongs to.
        /// This field will be empty until the files has been parsed
        /// </summary>
        /// <returns></returns>
        public string Domain
        {
            get
            {
                return _domain;
            }
        }

        /// <summary>
        /// Returns the locale this template is intended for
        /// </summary>
        public LanguageCode Locale
        {
            get
            {
                return _locale;
            }
        }

        /// <summary>
        /// Adds a pattern to the set of templates.
        /// </summary>
        /// <param name="patternToAdd"></param>
        public void AddPattern(TrainingUtterance patternToAdd)
        {
            allPatterns.Add(patternToAdd);
        }

        public void AddGroup(string groupName, string[] groupData)
        {
            string groupLower = groupName.ToLowerInvariant();
            if (allGroups.ContainsKey(groupLower))
            {
                throw new ArgumentException("Group " + groupName + " already exists!");
            }
           allGroups[groupLower] = groupData;
        }

        public string[] GetGroup(string groupName)
        {
            string groupLower = groupName.ToLowerInvariant();
            if (!allGroups.ContainsKey(groupLower))
            {
                return null;
            }
            return allGroups[groupLower];
        }

        /// <summary>
        /// Checks that all training lines use the same domain
        /// </summary>
        /// <param name="utterance"></param>
        /// <returns></returns>
        private bool CheckDomain(TrainingUtterance utterance)
        {
            if (string.IsNullOrEmpty(_domain))
            {
                _domain = utterance.Domain;
                return true;
            }
            return _domain.Equals(utterance.Domain);
        }

        /// <summary>
        /// Applies a group substitution within a regex, replacing {{groupname}} with (item1|item2|item3......)
        /// </summary>
        /// <param name="regex">The input regex</param>
        /// <returns>The formatted regex</returns>
        private string ApplySubstitutionsInRegex(string regex)
        {
            // list of subtitution points: (startIdx, endIdx, groupName)
            List<Tuple<int, int, string>> subPoints = new List<Tuple<int, int, string>>();

            MatchCollection m = regexSubExtractRegex.Matches(regex);
            foreach (Match match in m)
            {
                string groupName = match.Groups[1].Value;
                if (!allGroups.ContainsKey(groupName))
                {
                    throw new FormatException("Regex " + regex + " references an invalid group " + groupName);
                }

                subPoints.Add(new Tuple<int, int, string>(match.Index, match.Index + match.Length, groupName));
            }

            // Process all substitutions in reverse order so we don't overwrite future substitutions
            using (PooledStringBuilder pooledSb = StringBuilderPool.Rent())
            {
                StringBuilder reformattedRegex = pooledSb.Builder;
                for (int subIdx = subPoints.Count - 1; subIdx >= 0; subIdx--)
                {
                    Tuple<int, int, string> sub = subPoints[subIdx];
                    string[] subGroup = allGroups[sub.Item3];
                    if (subGroup.Length > 200)
                    {
                        throw new FormatException("Cannot substitute more than 200 items at a time into a regex");
                    }

                    reformattedRegex.Clear();
                    reformattedRegex.Append(regex, 0, sub.Item1);
                    // Turn the substitution point into a non-capturing disjunction group
                    reformattedRegex.Append("(?:");
                    for (int i = 0; i < subGroup.Length; i++)
                    {
                        reformattedRegex.Append(Regex.Escape(subGroup[i]));
                        if (i < subGroup.Length - 1)
                        {
                            reformattedRegex.Append("|");
                        }
                    }

                    reformattedRegex.Append(")");
                    if (regex.Length > sub.Item2)
                    {
                        reformattedRegex.Append(regex, sub.Item2, regex.Length - sub.Item2);
                    }

                    regex = reformattedRegex.ToString();
                }
            }

            return regex;
        }

        /// <summary>
        /// Applies substitution groups within regexes and ensures that they are valid
        /// </summary>
        private void FinalizeRegexes()
        {
            // Modify each regex/utterance value in-place
            foreach (TrainingUtterance regex in whitelistRegex)
            {
                try
                {
                    regex.Utterance = ApplySubstitutionsInRegex(regex.Utterance);
                    // Make sure the regex parses, but don't save it
                    Regex test = new Regex(regex.Utterance, RegexOptions.None);
                }
                catch (Exception)
                {
                    throw new FormatException("Invalid regex: " + regex);
                }
            }

            foreach (TrainingUtterance regex in blacklistRegex)
            {
                try
                {
                    regex.Utterance = ApplySubstitutionsInRegex(regex.Utterance);
                    // Make sure the regex parses, but don't save it
                    Regex test = new Regex(regex.Utterance, RegexOptions.None);
                }
                catch (Exception)
                {
                    throw new FormatException("Invalid regex: " + regex);
                }
            }
        }

        private void FinalizeGroup(string currentGroupName, TemplateGroup currentGroupType, List<string> itemsInCurrentGroup, Counter<string> intentCounter)
        {
            switch (currentGroupType)
            {
                case TemplateGroup.Patterns:
                    foreach (string item in itemsInCurrentGroup)
                    {
                        TrainingUtterance utterance = new TrainingUtterance();
                        if (utterance.Parse(item))
                        {
                            if (!CheckDomain(utterance))
                            {
                                throw new FormatException("Training files may only contain one domain: expected " + _domain + ", found " + utterance.Domain);
                            }
                            AddPattern(utterance);
                            intentCounter.Increment(utterance.Intent);
                        }
                        else
                        {
                            throw new FormatException("Badly formatted training pattern: \"" + item + "\"");
                        }
                    }
                    break;
                case TemplateGroup.Static:
                    // Parse statics as utterances
                    foreach (string item in itemsInCurrentGroup)
                    {
                        TrainingUtterance utterance = new TrainingUtterance();
                        if (utterance.Parse(item))
                        {
                            if (!CheckDomain(utterance))
                            {
                                throw new FormatException("Training files may only contain one domain: expected " + _domain + ", found " + utterance.Domain);
                            }
                            allStatics.Add(utterance);
                            intentCounter.Increment(utterance.Intent);
                        }
                        else
                        {
                            throw new FormatException("Badly formatted training line: \"" + item + "\"");

                        }
                    }
                    break;
                case TemplateGroup.Group:
                    AddGroup(currentGroupName, itemsInCurrentGroup.ToArray());
                    break;
                case TemplateGroup.Catalog: // This line allows for "hybrid" catalog groups that have extra data
                    AddGroup(currentGroupName, itemsInCurrentGroup.ToArray());
                    break;
                case TemplateGroup.Regex:
                    foreach (string item in itemsInCurrentGroup)
                    {
                        TrainingUtterance utterance = new TrainingUtterance();
                        if (utterance.Parse(item))
                        {
                            if (!CheckDomain(utterance))
                            {
                                throw new FormatException("Training files may only contain one domain: expected " + _domain + ", found " + utterance.Domain);
                            }

                            // The regexes here may require expansion still. So the value that is put here is only temporary
                            whitelistRegex.Add(utterance);
                        }
                        else
                        {
                            throw new FormatException("Badly formatted training line: " + item);
                        }
                    }
                    break;
                case TemplateGroup.RegexBlacklist:
                    foreach (string item in itemsInCurrentGroup)
                    {
                        TrainingUtterance utterance = new TrainingUtterance();
                        if (utterance.Parse(item))
                        {
                            if (!CheckDomain(utterance))
                            {
                                throw new FormatException("Training files may only contain one domain: expected " + _domain + ", found " + utterance.Domain);
                            }

                            // As above, this value is only temporary
                            blacklistRegex.Add(utterance);
                        }
                        else
                        {
                            throw new FormatException("Badly formatted training line: " + item);
                        }
                    }
                    break;
            }
        }
    }
}

using Durandal.Common.Cache;
using Durandal.Common.Tasks;
using Durandal.Common.Client;

namespace Durandal.Common.Net
{
    using Client;
    using Durandal.API;
    using Durandal.Common.Dialog;
    using Durandal.Common.Logger;
    using Durandal.Common.Security;
    using Durandal.Common.Utils;
    using Http;
    using Instrumentation;
    using Newtonsoft.Json;
    using Security.Client;
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Net;
    using System.Text;
    using System.Threading;
    using System.Threading.Tasks;
    using Durandal.Common.Time;
    using Durandal.Common.Events;
    using Durandal.Common.ServiceMgmt;

    /// <summary>
    /// This class handles the task of serving HTML pages that are generated by dialog plugins
    /// by using a local HTTP web server.
    /// In all cases, this server will be run on the client-side (and usually from inside of ClientCore).
    /// </summary>
    public class PresentationWebServer : IHttpServerDelegate, IClientPresentationLayer, IDisposable
    {
        private const int DEFAULT_LINGER_TIME = 86400;

        /// <summary>
        /// We need a Dialog connection here because we need to pass on /action, /view , and /query requests from the client.
        /// The action flows like this:
        ///     Client's web browser (user clicks)
        ///     -> This server (generate a request context)
        ///     -> Proxy to the dialog server (execute the action)
        ///     -> The (durandal-encoded) response comes back and gets converted into a HTTP 303 REDIRECT response
        ///     -> The client web browser opens the proper view that was defined in the raw response
        /// </summary>
        private IDialogClient _dialogConnection;

        /// <summary>
        /// Store html from the dialog engine in a cache. This cache is indexed using the GUID contained in the URL /cache?page={PAGEID} 
        /// </summary>
        private readonly InMemoryCache<string> _pageCache;

        /// <summary>
        /// A hook back into the client that lets us request context objects for new dialog requests
        /// </summary>
        private ClientContextFactory _contextGenerator;

        /// <summary>
        /// The authenticator object that validates new client requests
        /// </summary>
        private ClientAuthenticator _requestAuthenticator;

        private IClientHtmlRenderer _fallbackRenderer;

        private ILogger _logger;

        private ILogger _clientJavascriptLogger;

        private IHttpServer _baseServer;

        private readonly IDictionary<string, string> _clientJavascriptData = new Dictionary<string, string>();

        private string _localEndpoint;
        private int _disposed = 0;

        public PresentationWebServer(
            IHttpServer baseServer,
            ILogger logger)
        {
            _pageCache = new InMemoryCache<string>();
            _logger = logger;
            _clientJavascriptLogger = _logger.Clone("ClientJavascript");
            _baseServer = baseServer;
            _baseServer.RegisterSubclass(this);
            if (_baseServer.LocalAccessUri == null)
            {
                _localEndpoint = "durandal://";
            }
            else
            {
                _localEndpoint = string.Format("{0}://{1}:{2}", _baseServer.LocalAccessUri.Scheme, _baseServer.LocalAccessUri.Host, _baseServer.LocalAccessUri.Port);
            }

            DebugMemoryLeakTracer.TraceDisposableItemCreated(this);
        }

#if TRACK_IDISPOSABLE_LEAKS
        ~PresentationWebServer()
        {
            Dispose(false);
        }
#endif

        public void Initialize(IDialogClient dialogConnection,
            ClientContextFactory contextGenerator,
            ClientAuthenticator authenticator = null,
            IClientHtmlRenderer localMessageRenderer = null)
        {
            _dialogConnection = dialogConnection;
            _contextGenerator = contextGenerator;
            _requestAuthenticator = authenticator;
            _fallbackRenderer = localMessageRenderer;
        }
        
        public Task<bool> Start(CancellationToken cancelToken, IRealTimeProvider realTime)
        {
            _logger.Log("Starting presentation web server");
            return _baseServer.StartServer("ClientHTTP", cancelToken, realTime);
        }

        public Task Stop(CancellationToken cancelToken, IRealTimeProvider realTime)
        {
            _logger.Log("Stopping presentation web server");
            return _baseServer.StopServer(cancelToken, realTime);
        }

        public void UpdateNextTurnTraceId(Guid? traceId)
        {
            if (_logger != null)
            {
                _logger = _logger.CreateTraceLogger(traceId);
            }
            if (_clientJavascriptLogger != null)
            {
                _clientJavascriptLogger = _clientJavascriptLogger.CreateTraceLogger(traceId);
            }
        }

        public IDictionary<string, string> GetClientJavascriptData()
        {
            return _clientJavascriptData;
        }

        private void AddClientJavascriptDataToRequest(DialogRequest request)
        {
            if (_clientJavascriptData == null)
            {
                return;
            }

            foreach (var kvp in _clientJavascriptData)
            {
                if (request.RequestData.ContainsKey(kvp.Key))
                {
                    _logger.Log("Client javascript set a value for " + kvp.Key + " but that field was already set in the context!", LogLevel.Wrn);
                }

                request.RequestData[kvp.Key] = kvp.Value;
            }
        }

        [System.Diagnostics.CodeAnalysis.SuppressMessage("Reliability", "CA2000:Dispose objects before losing scope", Justification = "This method returns an IDisposable so the caller should be responsible for disposal")]
        public async Task HandleConnection(IHttpServerContext serverContext, CancellationToken cancelToken, IRealTimeProvider realTime)
        {
            HttpRequest clientRequest = serverContext.HttpRequest;
            HttpResponse response;

            try
            {
                if (clientRequest.RequestFile.StartsWith("/action"))
                {
                    // BEGIN TURN 2+ - Client's browser executes a dialog action
                    // The key to access the associated DialogAction is encoded in the URL
                    response = HttpResponse.ServerErrorResponse();
                    _logger.Log("Got a dialog action request");

                    if (clientRequest.GetParameters.ContainsKey("key"))
                    {
                        DialogRequest request = new DialogRequest();

                        // Call the delegate to generate a request context for us
                        request.ClientContext = _contextGenerator();
                        request.TraceId = _logger.TraceId.HasValue ? CommonInstrumentation.FormatTraceId(_logger.TraceId.Value) : null;
                        AddClientJavascriptDataToRequest(request);

                        // Authenticate the request
                        if (_requestAuthenticator != null)
                        {
                            Stopwatch authTimer = Stopwatch.StartNew();
                            await _requestAuthenticator.AuthenticateClientRequest(request, _logger, realTime).ConfigureAwait(false);
                            authTimer.Stop();
                            _logger.Log(CommonInstrumentation.GenerateLatencyEntry(CommonInstrumentation.Key_Latency_Client_GenerateRequestToken, authTimer), LogLevel.Ins);
                        }
                        
                        NetworkResponseInstrumented<DialogResponse> durandalResult =
                            await _dialogConnection.MakeDialogActionRequest(
                                request, clientRequest.GetParameters["key"], _logger, cancelToken, realTime).ConfigureAwait(false);
                        if (durandalResult != null && durandalResult.Response != null)
                        {
                            // Was the original method a PUT? Then this is an SPA query
                            if (clientRequest.RequestMethod.Equals("PUT"))
                            {
                                _logger.Log("Converting SPA response for client", LogLevel.Vrb);
                                if (durandalResult.Response.ExecutionResult == Result.Success)
                                {
                                    // Just return the extracted dictionary
                                    response = HttpResponse.OKResponse();
                                    DialogActionSpaResponse jsonResponse = new DialogActionSpaResponse()
                                    {
                                        Success = true,
                                        Message = null,
                                        Data = durandalResult.Response.ResponseData
                                    };

                                    response.SetContentJson(jsonResponse);
                                    _logger.Log("SPA response looks good", LogLevel.Std);
                                    OnUserInteraction(durandalResult.Response);
                                }
                                else
                                {
                                    // Some error happened
                                    response = HttpResponse.ServerErrorResponse();
                                    DialogActionSpaResponse jsonResponse = new DialogActionSpaResponse()
                                    {
                                        Success = false,
                                        Message = durandalResult.Response.ErrorMessage
                                    };

                                    _logger.Log("SPA error occurred: " + durandalResult.Response.ErrorMessage, LogLevel.Err);

                                    response.SetContentJson(jsonResponse);
                                    OnUserInteractionError();
                                }
                            }
                            else
                            {
                                if (durandalResult.Response.ExecutionResult == Result.Success)
                                {
                                    // Send an HTTP 303 to redirect the client to the new response
                                    // (If we just write the response directly back to the user, it could lead to double-submission and stuff)
                                    Uri redirectUrl = await GeneratePresentationUrlFromResponse(durandalResult.Response, realTime).ConfigureAwait(false);
                                    if (redirectUrl != null)
                                    {
                                        response = HttpResponse.RedirectResponse(redirectUrl);
                                    }
                                    else
                                    {
                                        _logger.Log("Could not cache the page that resulted from the dialog action", LogLevel.Err);
                                    }

                                    OnUserInteraction(durandalResult.Response);
                                }
                                else
                                {
                                    response = HttpResponse.ServerErrorResponse();
                                    if (!string.IsNullOrEmpty(durandalResult.Response.ErrorMessage))
                                    {
                                        response.SetContent(durandalResult.Response.ErrorMessage);
                                    }

                                    _logger.Log("Dialog action error occurred: " + durandalResult.Response.ErrorMessage, LogLevel.Err);
                                    OnUserInteractionError();
                                }
                            }

                            // Write instrumentation (this is identical to what is in ClientCore.DialogActionRequestInternal)
                            _logger.Log(CommonInstrumentation.GenerateSizeEntry(CommonInstrumentation.Key_Size_Client_Request, durandalResult.RequestSize), LogLevel.Ins);
                            _logger.Log(CommonInstrumentation.GenerateSizeEntry(CommonInstrumentation.Key_Size_Client_Response, durandalResult.ResponseSize), LogLevel.Ins);
                            _logger.Log(CommonInstrumentation.GenerateLatencyEntry(CommonInstrumentation.Key_Latency_Client_E2E, durandalResult.EndToEndLatency), LogLevel.Ins);
                        }
                    }
                }
                else if (clientRequest.RequestFile.StartsWith("/query"))
                {
                    if (clientRequest.GetParameters.ContainsKey("q"))
                    {
                        // Client is executing a programmatic query, i.e. a "deeplinked query".
                        // We need to intercept this 
                        response = HttpResponse.ServerErrorResponse();
                        string query = clientRequest.GetParameters["q"];
                        _logger.Log("Got a /query request \"" + query + "\", appending client context...");
                        DialogRequest request = new DialogRequest()
                        {
                            TextInput = query,
                            TraceId = _logger.TraceId.HasValue ? CommonInstrumentation.FormatTraceId(_logger.TraceId.Value) : null
                        };

                        // Call the delegate to generate a request context for us
                        request.ClientContext = _contextGenerator();

                        // Authenticate the request
                        if (_requestAuthenticator != null)
                        {
                            Stopwatch authTimer = Stopwatch.StartNew();
                            await _requestAuthenticator.AuthenticateClientRequest(request, _logger, realTime).ConfigureAwait(false);
                            authTimer.Stop();
                            _logger.Log(CommonInstrumentation.GenerateLatencyEntry(CommonInstrumentation.Key_Latency_Client_GenerateRequestToken, authTimer), LogLevel.Ins);
                        }

                        // Process the query
                        NetworkResponseInstrumented<DialogResponse> durandalResult =
                            await _dialogConnection.MakeQueryRequest(request, _logger, cancelToken, realTime).ConfigureAwait(false);
                        if (durandalResult.Response.ExecutionResult == Result.Success)
                        {
                            // Send an HTTP 303 to redirect the client to the new response
                            // (If we just write the response directly back to the user, it could lead to double-submission and stuff)
                            Uri redirectUrl = await GeneratePresentationUrlFromResponse(durandalResult.Response, realTime).ConfigureAwait(false);
                            if (redirectUrl != null)
                            {
                                response = HttpResponse.RedirectResponse(redirectUrl);
                            }
                            else
                            {
                                _logger.Log("Could not cache the page that resulted from the dialog query", LogLevel.Err);
                            }

                            OnUserInteraction(durandalResult.Response);
                        }
                        else
                        {
                            response = HttpResponse.ServerErrorResponse();
                            if (!string.IsNullOrEmpty(durandalResult.Response.ErrorMessage))
                            {
                                response.SetContent(durandalResult.Response.ErrorMessage);
                            }

                            _logger.Log("Dialog error occurred: " + durandalResult.Response.ErrorMessage, LogLevel.Err);
                            OnUserInteractionError();
                        }
                    }
                    else
                    {
                        response = HttpResponse.BadRequestResponse("Requests made to /query require a q={} url parameter");
                        OnUserInteractionError();
                    }
                }
                else if (clientRequest.RequestFile.Equals("/local") && clientRequest.GetParameters.ContainsKey("page"))
                {
                    // AFTER TURN 1+ - Client's web browser talks to local cache server
                    // Execute the HTTP server workflow
                    string pageKey = clientRequest.GetParameters["page"];
                    response = HttpResponse.OKResponse();
                    RetrieveResult<string> htmlCacheResult = await _pageCache.TryRetrieve(pageKey, _logger, realTime).ConfigureAwait(false);
                    string webpage;
                    if (htmlCacheResult.Success)
                    {
                        webpage = htmlCacheResult.Result;
                    }
                    else if (_fallbackRenderer != null)
                    {
                        webpage = _fallbackRenderer.RenderErrorMessage("The requested page has expired from the server");
                    }
                    else
                    {
                        webpage = "The requested page has expired from the server";
                    }

                    response.SetContent(webpage);

                    // We also take this as a signal that the client's main view is changing, so we clear all variables set by client-side javascript
                    _clientJavascriptData.Clear();
                }
                else if (clientRequest.RequestFile.StartsWith("/views") ||
                    clientRequest.RequestFile.Equals("/cache") && clientRequest.GetParameters.ContainsKey("data"))
                {
                    // Pipe requests for static resources to the dialog client itself, which will typically implement an http proxy for us
                    response = await _dialogConnection.MakeStaticResourceRequest(clientRequest, _logger, cancelToken, realTime).ConfigureAwait(false);
                    response.MakeProxied();
                }
                else if (clientRequest.RequestFile.Equals("/js/enabled"))
                {
                    // Signals to DurandalAssistant.js that this client is serving html locally and we can use this server to pass messages back and forth
                    // to the client layer (as an alternative to signaling via window.notify or other external scripting object)
                    response = HttpResponse.OKResponse();
                }
                else if (clientRequest.RequestFile.Equals("/js/log"))
                {
                    // Handle when local javascript running DurandalAssistant.js sends us a debug message to log
                    response = HttpResponse.OKResponse();
                    if (_clientJavascriptLogger != null)
                    {
                        ArraySegment<byte> reqPayload = await clientRequest.ReadContentAsByteArrayAsync(cancelToken, realTime).ConfigureAwait(false);
                        string logMessage = StringUtils.UTF8_WITHOUT_BOM.GetString(reqPayload.Array, reqPayload.Offset, reqPayload.Count);
                        _clientJavascriptLogger.Log(logMessage);
                    }
                }
                else if (clientRequest.RequestFile.Equals("/js/data"))
                {
                    // Handle when local javascript running DurandalAssistant.js sends us request data to include in the next request
                    response = HttpResponse.OKResponse();
                    HttpFormParameters newParameters = await clientRequest.ReadContentAsFormDataAsync(cancelToken, realTime).ConfigureAwait(false);
                    if (newParameters != null && newParameters.KeyCount != 0)
                    {
                        foreach (var kvp in newParameters)
                        {
                            if (_clientJavascriptData.ContainsKey(kvp.Key))
                            {
                                _clientJavascriptData.Remove(kvp.Key);
                            }

                            // BUGBUG: this doesn't work properly if the same parameter is specified multiple times. We just ignore
                            // the list of values and the last one in the list is the one that actually persists
                            foreach (var actualValue in kvp.Value)
                            {
                                _clientJavascriptData[kvp.Key] = actualValue;
                                _clientJavascriptLogger.Log("Client javascript set request variable " + kvp.Key + "=" + kvp.Value, LogLevel.Vrb);
                            }
                        }
                    }
                }
                else if (clientRequest.RequestFile.Equals("/"))
                {
                    response = HttpResponse.OKResponse();
                    response.SetContent("<html><body>Dr. Grant, the phones are working</body></html>", "text/html");
                }
                else
                {
                    response = HttpResponse.NotFoundResponse();
                    string logMessage = "Unknown URL sent to local http proxy: " + clientRequest.RequestFile;
                    _logger.Log(logMessage, LogLevel.Wrn);
                    response.SetContent(logMessage);
                }

#if DEBUG
                using (PooledStringBuilder requestUrlBuilder = StringBuilderPool.Rent())
                {
                    StringBuilder requestUrl = requestUrlBuilder.Builder;
                    requestUrl.Append(clientRequest.RequestMethod);
                    requestUrl.Append(' ');
                    requestUrl.Append(clientRequest.RequestFile);
                    bool first = true;
                    if (clientRequest.GetParameters.KeyCount > 0)
                    {
                        foreach (var param in clientRequest.GetParameters)
                        {
                            if (first)
                            {
                                requestUrl.Append('?');
                                first = false;
                            }
                            else
                            {

                                requestUrl.Append("&");
                            }
                            foreach (var getParamValue in param.Value)
                            {
                                requestUrl.Append(WebUtility.UrlEncode(param.Key));
                                requestUrl.Append("=");
                                requestUrl.Append(WebUtility.UrlEncode(getParamValue));
                            }
                        }
                    }

                    string responseMessage = response.ResponseCode.ToString() + " " + response.ResponseMessage;
                    if (response.ResponseCode == 303 && response.ResponseHeaders.ContainsKey("Location"))
                    {
                        responseMessage = response.ResponseCode.ToString() + " " + response.ResponseMessage + " " + response.ResponseHeaders["Location"];
                    }

                    _logger.Log(requestUrl.ToString() + " -> " + responseMessage);
                }
#endif
            }
            catch (Exception e)
            {
                response = HttpResponse.ClientErrorResponse("A client error occurred");
                string errorMessage = e.GetType().Name + ": " + e.Message;
                response.SetContent(errorMessage);
                _logger.Log(e, LogLevel.Err);
            }

            if (response != null)
            {
                try
                {
                    await serverContext.WritePrimaryResponse(response, _logger, cancelToken, realTime).ConfigureAwait(false);
                }
                catch (Exception e)
                {
                    _logger.Log(e, LogLevel.Err);
                }
            }
        }

        private async Task<string> CachePage(string html, IRealTimeProvider realTime)
        {
            string key = Guid.NewGuid().ToString("N");
            await _pageCache.Store(key, html, null, TimeSpan.FromMinutes(10), false, _logger, realTime).ConfigureAwait(false);
            return key;
        }

        public async Task<string> GetCachedPage(string pageKey, IRealTimeProvider realTime)
        {
            RetrieveResult<string> result = await _pageCache.TryRetrieve(pageKey, _logger, realTime).ConfigureAwait(false);
            if (result.Success)
            {
                return result.Result;
            }

            return null;
        }

        public async Task<Uri> GeneratePresentationUrlFromResponse(DialogResponse durandalResult, IRealTimeProvider realTime)
        {
            if (!string.IsNullOrWhiteSpace(durandalResult.ResponseHtml))
            {
                // Store the page in the cache and generate a URL to access it
                string pageKey = await CachePage(durandalResult.ResponseHtml, realTime).ConfigureAwait(false);
                _logger.Log("Storing response HTML into local presentation cache, page key is " + pageKey, LogLevel.Vrb);
                string finalUrl = _localEndpoint + "/local?page=" + pageKey;
                _logger.Log("Cached HTML URL = " + finalUrl);
                return new Uri(finalUrl);
            }
            // Open an external url
            else if (durandalResult.UrlScope == UrlScope.External && !string.IsNullOrWhiteSpace(durandalResult.ResponseUrl))
            {
                if (durandalResult.ResponseUrl.StartsWith("/"))
                {
                    _logger.Log("The client returned an external URL with a relative path, which is invalid.", LogLevel.Err);
                    return null;
                }
                else
                {
                    _logger.Log("Navigating to external URL " + durandalResult.ResponseUrl);
                    return new Uri(durandalResult.ResponseUrl);
                }
            }
            else if (!string.IsNullOrWhiteSpace(durandalResult.ResponseText))
            {
                string generatedHtml = durandalResult.ResponseText;
                if (_fallbackRenderer != null)
                {
                    generatedHtml = _fallbackRenderer.RenderMessage(durandalResult.ResponseText);
                }

                string pageKey = await CachePage(generatedHtml, realTime).ConfigureAwait(false);
                _logger.Log("Did not get HTML response back, converting text response into HTML; page key is " + pageKey);
                string finalUrl = _localEndpoint + "/local?page=" + pageKey;
                _logger.Log("Cached HTML URL = " + finalUrl);
                return new Uri(finalUrl);
            }
            else
            {
                _logger.Log("Unable to determine any web content to show in the response (This is normal if the plugin did not return text or HTML)", LogLevel.Wrn);
            }

            return null;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!AtomicOperations.ExecuteOnce(ref _disposed))
            {
                return;
            }

            DebugMemoryLeakTracer.TraceDisposableItemDisposed(this, disposing);

            if (disposing)
            {
                _baseServer?.Dispose();
                _pageCache?.Dispose();
            }
        }

        /// <summary>
        /// Fired when the user clicks a link on the web page to trigger a dialog action or deeplinked query.
        /// The returned time span indicates the conversation lifetime that is reported by the dialog server as a result of this navigation
        /// </summary>
        public event EventHandler<TimeSpanEventArgs> UserInteraction;

        /// <summary>
        /// Fired when the user interacted with some link on the HTML page and the resulting operation hit an error
        /// </summary>
        public event EventHandler UserInteractionError;

        protected virtual void OnUserInteraction(DialogResponse dialogResponse)
        {
            int? lifetimeSeconds = dialogResponse.ConversationLifetimeSeconds;
            int actualLingerTime;
            if (lifetimeSeconds.HasValue && lifetimeSeconds.Value > 0)
            {
                actualLingerTime = lifetimeSeconds.Value;
            }
            else
            {
                actualLingerTime = DEFAULT_LINGER_TIME;
            }

            TimeSpanEventArgs args = new TimeSpanEventArgs(TimeSpan.FromSeconds(actualLingerTime));

            EventHandler<TimeSpanEventArgs> handler = UserInteraction;
            if (handler != null)
            {
                handler(this, args);
            }
        }
        
        protected virtual void OnUserInteractionError()
        {
            EventHandler handler = UserInteractionError;
            if (handler != null)
            {
                handler(this, new EventArgs());
            }
        }
    }
}

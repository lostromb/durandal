using Durandal.Common.Logger;
using Durandal.Common.MathExt;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Collections;
using System.Threading;
using Durandal.Common.Utils;
using Durandal.Common.ServiceMgmt;

namespace Durandal.Common.NLP.Train
{
    public class TemplateFileExpanderBalanced : ITrainingDataStream
    {
        private readonly Regex groupExtractRegex = new Regex("\\{(.+?)\\}");

        // Used for template autobalancing
        private const int MAX_STATIC_DUPLICATION_COUNT = 50;
        private const int MAX_PATTERN_DUPLICATION_COUNT = 20;

        // The main control for how much training data to output from expanded templates.
        private const float EXPANSION_FACTOR = 3f;

        private TrainingDataTemplate _template;
        private ILogger _logger;
        private IEnumerator<TrainingUtterance> _enumerator;
        private int _recommendedOutputCount = -1;

        // These will go away once I move to infinite streams
        private int _minDesiredInstances;
        private float _fraction;

        private int _disposed = 0;

        public TemplateFileExpanderBalanced(TrainingDataTemplate template, ILogger logger, float fraction, int minInstances)
        {
            _template = template;
            _logger = logger;
            _fraction = fraction;
            _minDesiredInstances = minInstances;
            _enumerator = GenerateData(new FastRandom(88), _fraction, _minDesiredInstances).GetEnumerator();
            DebugMemoryLeakTracer.TraceDisposableItemCreated(this);
        }

#if TRACK_IDISPOSABLE_LEAKS
        ~TemplateFileExpanderBalanced()
        {
            Dispose(false);
        }
#endif

        public TrainingUtterance Current
        {
            get
            {
                return _enumerator.Current;
            }
        }

        object IEnumerator.Current
        {
            get
            {
                return _enumerator.Current;
            }
        }

        public int RecommendedOutputCount
        {
            get
            {
                // Lazily calculate this value since it's not always needed
                if (_recommendedOutputCount < 0)
                {
                    _recommendedOutputCount = Math.Max(1, CalculateRecommendedExpansionCount());
                }

                return _recommendedOutputCount;
            }
        }

        public bool MoveNext()
        {
            return _enumerator.MoveNext();
        }

        public void Reset()
        {
            throw new NotImplementedException("Cannot reset an infinite stream");
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!AtomicOperations.ExecuteOnce(ref _disposed))
            {
                return;
            }

            DebugMemoryLeakTracer.TraceDisposableItemDisposed(this, disposing);

            if (disposing)
            {
                _enumerator.Dispose();
            }
        }

        /// <summary>
        /// Returns the number of raw data lines that would be generated by a single pattern
        /// </summary>
        /// <returns></returns>
        private long CalculatedGeneratedLineCount(TrainingUtterance pattern)
        {
            long count = 0;

            // Find the number of permutations generated by each pattern based on their group sizes
            long multiplier = 1;
            foreach (Match m in groupExtractRegex.Matches(pattern.Utterance))
            {
                string groupName = m.Groups[1].Value;
                string[] group = _template.GetGroup(groupName);
                if (group != null)
                {
                    multiplier *= (long)group.Length;
                }
            }
            count += multiplier;

            return count;
        }

        private int CalculateRecommendedExpansionCount()
        {
            // OPT: This method really does way too much work trying to be precise
            // Predict the outcome training instances for each intent
            double totalExpandedCount = 0;
            long theoreticalExpandedCount = 0;
            Counter<string> perIntentCounts = new Counter<string>();
            foreach (TrainingUtterance pattern in _template.Statics)
            {
                perIntentCounts.Increment(pattern.Intent);
                totalExpandedCount += 1;
                theoreticalExpandedCount += 1;
            }

            foreach (TrainingUtterance pattern in _template.Patterns)
            {
                double power = GetExponentialOrderOfPattern(pattern.Utterance);
                long theoreticalCount = CalculatedGeneratedLineCount(pattern);
                double normalizedCount = ReduceExponentialComplexity(theoreticalCount, power, 1.0f);
                perIntentCounts.Increment(pattern.Intent, (float)normalizedCount);
                totalExpandedCount += normalizedCount;
                theoreticalExpandedCount += theoreticalCount;
            }

            float highestCount = 0;
            foreach (KeyValuePair<string, float> x in perIntentCounts)
            {
                highestCount = Math.Max(x.Value, highestCount);
            }

            int targetIterations = (int)Math.Round(Math.Max(1, 6000 / totalExpandedCount));
            
            double returnVal = 0;
            for (int iterations = 0; iterations < targetIterations; iterations++)
            {
                // Start with static data
                foreach (TrainingUtterance line in _template.Statics)
                {
                    int multiplyFactor = (int)Math.Max(1, Math.Min(MAX_STATIC_DUPLICATION_COUNT, highestCount / perIntentCounts.GetCount(line.Intent)));
                    returnVal += multiplyFactor;
                }

                // Now each pattern
                foreach (TrainingUtterance pattern in _template.Patterns)
                {
                    List<Tuple<string, string>> replacePoints = new List<Tuple<string, string>>();
                    string formattedPattern = pattern.Utterance;
                    double power = GetExponentialOrderOfPattern(formattedPattern);
                    double expandedCount = CalculatedGeneratedLineCount(pattern);
                    double actualCount = ReduceExponentialComplexity(expandedCount, power, 1.0f);
                    int multiplyFactor = (int)Math.Max(1, Math.Min(MAX_PATTERN_DUPLICATION_COUNT,
                        highestCount / perIntentCounts.GetCount(pattern.Intent)));
                    returnVal += actualCount * multiplyFactor;
                }
            }

            _logger.Log(string.Format("Changing {0} training instances to {1}", theoreticalExpandedCount, returnVal), LogLevel.Vrb);

            return (int)returnVal;
        }

        private IEnumerable<TrainingUtterance> GenerateData(IRandom rand, float fraction, int minInstances)
        {
            // Predict the outcome training instances for each intent
            Counter<string> perIntentCounts = new Counter<string>();
            foreach (TrainingUtterance pattern in _template.Statics)
            {
                perIntentCounts.Increment(pattern.Intent);
            }

            foreach (TrainingUtterance pattern in _template.Patterns)
            {
                double power = GetExponentialOrderOfPattern(pattern.Utterance);
                long theoreticalCount = CalculatedGeneratedLineCount(pattern);
                double normalizedCount = ReduceExponentialComplexity(theoreticalCount, power, fraction);
                perIntentCounts.Increment(pattern.Intent, (float)normalizedCount);
            }

            float highestCount = 0;
            foreach (KeyValuePair<string, float> x in perIntentCounts)
            {
                highestCount = Math.Max(x.Value, highestCount);
            }

            bool running = true;

            // Iterate through each pattern and generate the permutations
            // This is an infinite loop UNLESS the pattern does not specify any statics or patterns (and therefore does not yield any values)
            while (running)
            {
                running = false;

                // Start with static data
                foreach (TrainingUtterance line in _template.Statics)
                {
                    int multiplyFactor = (int)Math.Max(1, Math.Min(MAX_STATIC_DUPLICATION_COUNT,
                        highestCount / perIntentCounts.GetCount(line.Intent)));
                    for (int c = 0; c < multiplyFactor; c++)
                    {
                        running = true;
                        yield return line;
                    }
                }

                // Now each pattern
                foreach (TrainingUtterance pattern in _template.Patterns)
                {
                    List<Tuple<string, string>> replacePoints = new List<Tuple<string, string>>();
                    string formattedPattern = pattern.Utterance;

                    // Find the affected groups
                    int newGroupIndex = 0;
                    List<string[]> groups = new List<string[]>();
                    foreach (Match m in groupExtractRegex.Matches(formattedPattern))
                    {
                        string groupName = m.Groups[1].Value;
                        string[] group = _template.GetGroup(groupName);
                        if (group == null)
                        {
                            throw new FormatException("Pattern " + pattern + " references unknown group " + groupName);
                        }
                        groups.Add(group);
                        replacePoints.Add(new Tuple<string, string>("{" + groupName + "}", "{" + (newGroupIndex++).ToString() + "}"));
                    }

                    // Find out what percentage of training should be randomly dropped
                    double power = GetExponentialOrderOfPattern(formattedPattern);
                    double expandedCount = CalculatedGeneratedLineCount(pattern);
                    double actualCount = ReduceExponentialComplexity(expandedCount, power, fraction);
                    int multiplyFactor = (int)Math.Max(1, Math.Min(MAX_PATTERN_DUPLICATION_COUNT,
                        highestCount / perIntentCounts.GetCount(pattern.Intent)));

                    if (expandedCount < 1)
                    {
                        _logger.Log("Pattern " + pattern.Utterance + " has no expansions; this is probably not intended", LogLevel.Wrn);
                    }

                    // And reformat the pattern to use 0-based indexing
                    foreach (Tuple<string, string> replacePoint in replacePoints)
                    {
                        formattedPattern = ReplaceFirst(formattedPattern, replacePoint.Item1, replacePoint.Item2);
                    }
                    for (int c = 0; c < multiplyFactor; c++)
                    {
                        IEnumerable<TrainingUtterance> subPermutations = StringPermutations(rand, pattern.Domain, pattern.Intent, formattedPattern, groups, actualCount, expandedCount);
                        foreach (TrainingUtterance u in subPermutations)
                        {
                            running = true;
                            yield return u;
                        }
                    }
                }
            }
        }

        private static IEnumerable<TrainingUtterance> StringPermutations(IRandom rand, string domain, string intent, string pattern, List<string[]> groups, double toReturn, double totalLines)
        {
            
            int groupCount = groups.Count;
            if (groupCount == 0)
            {
                yield break;
            }
        
            int[] indices = new int[groupCount];
            object[] strings = new string[groupCount];
            for (double current = 0; current < toReturn; current += 1)
            {
                TrainingUtterance next = null;

                // OPT does try-catch incur overhead here?
                try
                {
                    // Calculate indices for a random permutation
                    long newIndex = (long)(rand.NextDouble() * totalLines);
                    for (int check = groupCount - 1; check >= 0; check--)
                    {
                        indices[check] = (int)(newIndex % (long)groups[check].Length);
                        newIndex = newIndex / (long)groups[check].Length;
                    }

                    // And build that string
                    for (int c = 0; c < groupCount; c++)
                    {
                        strings[c] = groups[c][indices[c]];
                    }

                    next = new TrainingUtterance()
                    {
                        Domain = domain,
                        Intent = intent,
                        Utterance = string.Format(pattern, strings)
                    };
                }
                catch (FormatException e)
                {
                    throw new FormatException("Found a malformed template line: \"" + pattern + "\". Error is: " + e.Message);
                }
                    
                if (next != null)
                {
                    yield return next;
                }
            }
        }

        // Replaces only the first instance of a substring within a larger string
        private static string ReplaceFirst(string input, string original, string replacement)
        {
            int startIndex = input.IndexOf(original);
            if (startIndex < 0)
            {
                return input;
            }

            return input.Substring(0, startIndex) +
                replacement +
                input.Substring(startIndex + original.Length);
        }

        private static double ReduceExponentialComplexity(double input, double power, float fraction = 1.0f)
        {
            if (power < 1)
            {
                return input;
            }

            double returnVal;
            if (power < 2 && input > 100)
            {
                // This handles patterns that contain a single very long list - treat them as x^2 complexity instead of x
                returnVal = Math.Max(1, Math.Pow(input, 1 / (power + 1)) * EXPANSION_FACTOR * fraction);
            }
            else
            {
                returnVal = Math.Max(1, Math.Pow(input, 1 / (power)) * EXPANSION_FACTOR * fraction);
            }
            //Console.WriteLine(input + " " + power + " -> " + returnVal);
            return returnVal;
        }

        private static double GetExponentialOrderOfPattern(string pattern)
        {
            double returnVal = 0;
            for (int c = 0; c < pattern.Length; c++)
            {
                if (pattern[c] == '{')
                    returnVal++;
            }
            return returnVal;
        }
    }
}
